#!/usr/bin/env ruby

if ENV["RACK_ENV"].to_s.strip != ""
  raise "You must not set RACK_ENV in the environment"
end

ENV["RACK_ENV"] = "production"

require_relative "../bin/brut_cli"
require "optparse"

def parse_options
  options = {
    platform: "linux/amd64",
    dry_run: false,
    skip_checks: false,
  }
  OptionParser.new do |parser|
    parser.banner = %{Usage: #{$0} [options]}
    parser.on("--platform=PLATFORM","Override default platform. Can be any Docker platform. Default is '#{options[:platform]}'") do |value|
      options[:platform] = value
    end

    parser.on("--[no-]dry-run", "Print the commands that would be run and don't actually do anything") do |value|
      options[:dry_run] = value
    end

    parser.on("--[no-]skip-checks", "Skip checks for code having been committed and pushed") do |value|
      options[:skip_checks] = value
    end

  end.parse!
  options
end

def require_main_branch
  current_branch = `git branch --show-current`.strip.chomp

  if current_branch != "main"
    log "You are not on the 'main' branch, but on the '#{current_branch}' branch"
    log "You may only deploy from the 'main' branch"
    false
  else
    true
  end
end

def require_no_local_changes
  local_changes = `git diff-index --name-only HEAD --`
  if local_changes.strip != ""
    log "You have local changes:"
    local_changes.split(/\n/).each do |change|
      log "    #{change}"
    end
    log "Commit these, run bin/ci, then push to origin/main"
    false
  else
    true
  end
end

def require_pushed_to_main
  git_status = `git rev-list --left-right --count origin/main...main`.strip.chomp
  remote_ahead, local_ahead = git_status.split(/\t/,2).map(&:to_i)

  if remote_ahead != 0
    log "There are commits in origin you don't have. Pull those in, re-run bin/ci, THEN deploy"
    return false
  end

  if local_ahead != 0
    log "You have not pushed to origin. Do that before deploying"
    return false
  end
  true
end


options = parse_options

if options[:dry_run]
  def system!(*args)
    log "DRY RUN, NOT EXECUTING '#{args}'"
  end
end

version = begin
            git_guess = %{git rev-parse --short HEAD}
            stdout, stderr, status = Open3.capture3(git_guess)
            if status.success?
              stdout.strip
            else
              raise "Attempt to use git via command '#{git_guess}' to figure out the version failed: #{stdout}#{stderr}"
            end
          end

platform = options[:platform] || "linux/amd64"
heroku_app_name = Brut.container.app_id

log "Changing to #{ROOT_DIR}"
images = {
  "web" => {
    cmd: "bin/run",
    image_name: %{#{Brut.container.app_organization}/#{Brut.container.app_id}:#{version}-web},
    dockerfile: "deploy/Dockerfile.web",
    heroku_image_name: "registry.heroku.com/#{heroku_app_name}/web",
  },
  "release" => {
    cmd: "bin/release",
    image_name: %{#{Brut.container.app_organization}/#{Brut.container.app_id}:#{version}-release},
    dockerfile: "deploy/Dockerfile.release",
    heroku_image_name: "registry.heroku.com/#{heroku_app_name}/release",
  },
}

if !require_main_branch
  if options[:skip_checks]
    log "Ignoring since --skip-checks was specified"
  else
    exit 1
  end
end
if !require_no_local_changes
  if options[:skip_checks]
    log "Ignoring since --skip-checks was specified"
  else
    exit 1
  end
end
if !require_pushed_to_main
  if options[:skip_checks]
    log "Ignoring since --skip-checks was specified"
  else
    exit 1
  end
end

FileUtils.chdir ROOT_DIR do

  log "Generating Dockerfiles"
  images.each do |name,metadata|
    cmd        = metadata.fetch(:cmd)
    image_name = metadata.fetch(:image_name)
    dockerfile = metadata.fetch(:dockerfile)

    log "Creating '#{dockerfile}' for '#{name}' that will use command '#{cmd}'"
    File.open(dockerfile,"w") do |file|
      file.puts "# DO NOT EDIT - THIS IS GENERATED"
      file.puts File.read("deploy/Dockerfile")
      file.puts
      file.puts "# Added by #{$0}"
      file.puts %{CMD [ "bundle", "exec", "#{cmd}" ]}
    end
  end

  log "Building images"
  images.each do |name,metadata|
    cmd        = metadata.fetch(:cmd)
    image_name = metadata.fetch(:image_name)
    dockerfile = metadata.fetch(:dockerfile)

    log "Creating docker image with name '#{image_name}' and platform '#{platform}'"
    command = %{docker build --build-arg DOCKER_CMD='./bin/run' --file #{ROOT_DIR}/#{dockerfile} --platform #{platform} --tag #{image_name} .}
    system!(command)
  end

  log "Taggging images for Heroku"
  images.each do |name,metadata|
    cmd        = metadata.fetch(:cmd)
    image_name = metadata.fetch(:image_name)
    heroku_image_name = metadata.fetch(:heroku_image_name)

    log "Tagging '#{image_name}' with '#{heroku_image_name}' for Heroku"
    command = %{docker tag #{image_name} #{heroku_image_name}}
    system!(command)
  end

  log "Pushing to Heroku Registry"
  images.each do |name,metadata|
    heroku_image_name = metadata.fetch(:heroku_image_name)

    log "Pusing '#{heroku_image_name}'"
    command = %{docker push #{heroku_image_name}}
    system!(command)
  end
end
