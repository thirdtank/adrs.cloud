#!/usr/bin/env ruby

require "optparse"
require "sequel"
require "uri"
require "fileutils"
require "date"

require_relative "bin_kit"

Sequel.extension :migration

def parse_options
  options = {}
  OptionParser.new do |parser|
    parser.banner = %{Usage: #{$0} [options] «command»

COMMANDS

  create        - create the database if it doesn't exist
  drop          - drop the database if it exists
  migrate       - apply any outstanding migrations
  rebuild       - drops, then creates the db, then runs migrations
  status        - report on the status of the database and its migrations
  seeds         - load seed data
  new-migration - creates a new migration file. Arguments are the name/description of the migration

OPTIONS
}
    parser.on("--app-env=ENV","Env for the app. Must be development, test, or production") do |value|
      options[:app_env] = value
    end
    parser.on("--seeds","For rebuild only, load seeds after rebuild") do |value|
      options[:load_seeds] = !!value
    end

  end.parse!
  options
end

options = parse_options

class Command
  def self.from_string(string)
    case string
    when "create"        then Create
    when "drop"          then Drop
    when "migrate"       then Migrate
    when "new-migration" then NewMigration
    when "status"        then Status
    when "rebuild"       then Rebuild
    when "seeds"         then Seed
    else
      nil
    end
  rescue ArgumentError => ex
    puts "Problem parsing '#{database_uri}': #{ex.message}"
    raise
  end

  def self.default_env = nil
  def self.boot_app? = false

  def initialize(database_uri:, args:, options:)
    @database_uri  = database_uri
    @database_name = @database_uri.path.gsub(/^\//,"")
    @args          = args
    @options       = options
  end

  class Seed < Command
    def self.boot_app? = true

    def initialize(database_uri:,args:,options:)
    end

    def call
      seeds_dir = Brut.container.db_seeds_dir
      Dir["#{seeds_dir}/*.rb"].each do |file|
        require file
      end
      seed_data = Brut::Backend::SeedData.new
      seed_data.setup!
      seed_data.load_seeds!
    end
  end

  class Rebuild < Command
    def call
      Drop.new(database_uri: @database_uri, args: @args, options: @options).call
      Create.new(database_uri: @database_uri, args: @args, options: @options).call
      Migrate.new(database_uri: @database_uri, args: @args, options: @options).call
      if @options[:load_seeds]
        puts "Loading seed data"
        exec("#{$0} seeds --app-env=#{@options[:app_env]}")
      else
        puts "NOT Loading seed data, use --seeds if you want that"
      end
    end
  end

  class Create < Command
    def call
      connection = Sequel.connect(@database_uri.to_s)
      puts "Database already exists"
      connection.disconnect
      return
    rescue Sequel::DatabaseConnectionError
      uri_no_database = URI(@database_uri.to_s)
      uri_no_database.path = ""
      begin
        connection = Sequel.connect(uri_no_database.to_s)
        puts "#{@database_name} does not exit. Creating..."
        connection.run("CREATE DATABASE \"#{@database_name}\"")
        connection.disconnect
      rescue => ex
        puts ex.message
      end
    end
  end

  class Drop < Command
    def call
      uri_no_database = URI(@database_uri.to_s)
      uri_no_database.path = ""
      connection = Sequel.connect(@database_uri.to_s)
      puts "Database exists. Dropping..."
      connection.disconnect
      connection = Sequel.connect(uri_no_database.to_s)
      connection.run("DROP DATABASE \"#{@database_name}\"")
      connection.disconnect
      return
    rescue Sequel::DatabaseConnectionError
      begin
        connection = Sequel.connect(uri_no_database.to_s)
        puts "#{@database_name} does not exit."
        connection.disconnect
      rescue => ex
        puts ex.message
      end
    end
  end

  class Migrate < Command
    def call
      migrations_dir = Brut.container.migrations_dir
      if !migrations_dir.exist?
        puts "#{migrations_dir} doesn't exist"
        return
      end
      connection = Sequel.connect(@database_uri.to_s)
      Brut.container.sequel_db_handle.extension :pg_array
      Brut.container.sequel_db_handle.sql_log_level = :info

      Brut.container.sequel_db_handle.logger = SemanticLogger["Sequel::Database"]
      Sequel::Migrator.run(Brut.container.sequel_db_handle,migrations_dir)
      puts "Migrations applied"
    rescue Sequel::DatabaseConnectionError
      uri_no_database = URI(@database_uri.to_s)
      uri_no_database.path = ""
      begin
        connection = Sequel.connect(uri_no_database.to_s)
        puts "Database #{@database_name} does not exist - run bin/db create to create it"
      rescue => ex
        puts ex.message
      end
    end
  end

  class NewMigration < Command
    def self.default_env = "development"
    def call
      if @args.length == 0
        raise "You must provide a name"
      end
      migrations_dir = Brut.container.migrations_dir
      name = @args.join(" ").gsub(/[^\w\d\-]/,"-")
      date = DateTime.now.strftime("%Y%m%d%H%M%S")
      file_name = migrations_dir / "#{date}_#{name}.rb"
      File.open(file_name,"w") do |file|
        file.puts "Sequel.migration do"
        file.puts "  up do"
        file.puts "  end"
        file.puts "end"
      end
      puts "#{file_name} created"
    end
  end

  class Status < Command
    def call
      connection = Sequel.connect(@database_uri.to_s)
      puts "Database Server is Up"
      puts "Database #{@database_name} exists"
      migrations_run = if connection.table_exists?("schema_migrations")
                         connection["select filename from schema_migrations order by filename"].all.map { |_| _[:filename] }
                       else
                         []
                       end
      max_length = migrations_run.map(&:length).max
      printf_string = "%-#{max_length}s - %s\n"
      puts printf_string
      Dir[Brut.container.migrations_dir / "*.rb"].each do |file|
        filename = Pathname(file).basename.to_s
        applied = migrations_run.include?(filename)
        printf(printf_string,filename,applied ? "✅ APPLIED" : "❌ NOT APPLIED")
      end
    rescue Sequel::DatabaseConnectionError
      uri_no_database = URI(@database_uri.to_s)
      uri_no_database.path = ""
      begin
        connection = Sequel.connect(uri_no_database.to_s)
        puts "Database Server is Up"
        puts "Database #{@database_name} does not exist"
      rescue => ex
        puts ex.message
      end
    rescue => ex
      puts ex.class
      puts ex.message
    end
  end
end

if ARGV[0].to_s.strip == ""
  log "You must provide a command"
  exit 1
end


command_klass = Command.from_string(ARGV[0])
ENV["RACK_ENV"] = (options[:app_env] || command_klass.default_env).to_s.strip

if ENV["RACK_ENV"] == ""
  log "--app-env is required"
  exit 1
end

if command_klass.boot_app?
  require "bundler"
  Bundler.require
  $LOAD_PATH << File.join(__dir__,"..","lib")
  require_relative "../app/boot"
else
  require_relative "brut_cli"
end

command = command_klass.new(database_uri: URI(ENV["DATABASE_URL"]), args: ARGV[1..-1],options: options)

if !command
  log "'#{ARGV[0]}' is not a supported command"
  exit 1
end
command.call

