#!/usr/bin/env ruby

require "optparse"
require "pathname"
require "prism"
require "fileutils"

ENV["RACK_ENV"] = "development"
require_relative "brut_cli"

def parse_options
  options = {
    overwrite: false,
  }
  OptionParser.new do |parser|
    parser.banner = %{Usage: #{$0} [options] «command» [args]

Scaffolds various types of files.

COMMANDS

  test      - scaffolds test for the files given in args
  component - scaffolds a new component given by class name

OPTIONS
}
    parser.on("--overwrite", "If set, any files that exists already will be overwritten by new scaffolds") do |value|
      options[:overwrite] = !!value
    end
    parser.on("--dry-run", "If set, no files are changed. You will see output of what would happen without this flag") do |value|
      options[:dry_run] = !!value
    end
    parser.on("--page", "If set, this component will be placed in pages/ to allow it to be organized with an existing page") do |value|
      options[:page_component] = !!value
    end
  end.parse!
  options
end

options = parse_options

class Command
  def self.from_string(string, args:, options:)
    case string
    when "test" then Test.new(args:, options:)
    when "component" then Component.new(args:,options:)
    else
      nil
    end
  end

  def initialize(args:, options:)
    @args    = args
    @options = options
  end

  class Component < Command
    def call
      if @args.length != 1
        raise "component requires exactly one argument, got #{@args.length}"
      end
      class_name = RichString.new(@args[0])
      if class_name.to_s !~ /Component$/
        class_name = RichString.new(class_name.to_s + "Component")
      end

      relative_path = class_name.underscorized

      components_src_dir   = Brut.container.components_src_dir
      components_specs_dir = Brut.container.components_specs_dir

      if @options[:page_component]
        components_src_dir   = Brut.container.pages_src_dir
        components_specs_dir = Brut.container.pages_specs_dir
        if class_name.to_s !~ /::/
          raise "component #{class_name} cannot be a page component - it must be an inner class of an existing page"
        else
          existing_page = RichString.new(class_name.to_s.split(/::/)[0..-2].join("::")).underscorized.to_s + ".rb"

          if !(components_src_dir / existing_page).exist?
            raise "#{existing_page} is expected to exist but does not"
          end
        end
      end

      source_path      = Pathname( (components_src_dir / relative_path).to_s + ".rb" )
      html_source_path = Pathname( (components_src_dir / relative_path).to_s + ".html.erb" )
      spec_path        = Pathname( (components_specs_dir / relative_path).to_s + ".spec.rb" )

      exists = [
        source_path,
        html_source_path,
        spec_path,
      ].select(&:exist?)

      if exists.any?
        exists.each do |path|
          log "'#{path}' exists already"
        end
        return 1
      end

      if @options[:dry_run]
        puts "FileUtils.mkdir_p #{source_path.dirname}"
        puts "FileUtils.mkdir_p #{html_source_path.dirname}"
        puts "FileUtils.mkdir_p #{spec_path.dirname}"
      else
        FileUtils.mkdir_p source_path.dirname
        FileUtils.mkdir_p html_source_path.dirname
        FileUtils.mkdir_p spec_path.dirname

        File.open(source_path,"w") do |file|
          file.puts %{class #{class_name} < AppComponent
  def initialize
  end
end}
        end
        File.open(html_source_path,"w") do |file|
          file.puts "<h1>#{class_name} is ready!</h1>"
        end
        File.open(spec_path,"w") do |file|
          file.puts %{require "spec_helper"

RSpec.describe #{class_name} do
  it "should have tests"
    expect(true).to eq(false)
  end
end}
        end
      end
      log "Component source is in        #{source_path.relative_path_from(Brut.container.project_root)}"
      log "Component HTML template is in #{html_source_path.relative_path_from(Brut.container.project_root)}"
      log "Component test is in          #{spec_path.relative_path_from(Brut.container.project_root)}"
      0
    end
  end

  class Test < Command
    def call
      if @args.empty?
        log "'test' requires one or more files to scaffold a test for"
        return 1
      end
      files_to_test_files = @args.map { |arg|
        Pathname(arg).expand_path
      }.map { |pathname|
        relative = pathname.relative_path_from(Brut.container.app_src_dir)
        test_file = Brut.container.app_src_dir / "specs" / relative.dirname / "#{relative.basename(relative.extname)}.spec.rb"
        [ pathname, test_file ]
      }.to_h

      non_existent_sources  = files_to_test_files.keys.select   { |pathname| !pathname.exist? }
      existent_destinations = files_to_test_files.values.select { |pathname| pathname.exist? }

      if non_existent_sources.any?
        relative_paths = non_existent_sources.map { |pathname| pathname.relative_path_from(Brut.container.project_root) }
        log "Not all input files exist:"
        relative_paths.each do |file|
          log file
        end
        return 1
      end

      if existent_destinations.any? && !@options[:overwrite]
        relative_paths = existent_destinations.map { |pathname| pathname.relative_path_from(Brut.container.project_root) }
        log "Some files to be generated exist. Set --overwrite to overwrite them:"
        relative_paths.each do |file|
          log file
        end
        return 1
      end

      files_to_test_files.each do |source,destination|
        result = Prism.parse_file(source.to_s)
        if !result
          raise "WTF"
        end
        classes = find_classes(result.value).map { |(module_nodes,class_node)|
          (module_nodes.map(&:constant_path).map(&:full_name).map(&:to_s) + [class_node.constant_path.full_name.to_s]).compact.join("::")
        }


        log "#{destination} will contain tests for:\n#{classes.join("\n")}\n\n"

        code = ["require \"spec_helper\"\n"] + classes.map { |class_name|
          %{RSpec.describe #{class_name} do
  it "should have tests" do
    expect(false).to eq(true)
  end
end}
        }

        if @options[:dry_run]
          puts code
        else

          FileUtils.mkdir_p destination.dirname
          File.open(destination,"w") do |file|
            file.puts code
          end
        end
      end

      0

    end
  end

end


def find_classes(ast,current_modules = [])
  classes = []
  if ast.nil?
    return classes
  end
  new_module = nil
  if ast.kind_of?(Prism::ClassNode)
    classes << [ current_modules, ast ]
    new_module = ast
  elsif ast.kind_of?(Prism::ModuleNode)
    new_module = ast
  end
  ast.child_nodes.each do |child|
    new_current_modules = current_modules + [ new_module ]
    result = find_classes(child, new_current_modules.compact)
    classes = classes + result
  end
  classes
end

if ARGV[0].to_s.strip == ""
  log "You must provide a command"
  exit 1
end

command = Command.from_string(ARGV[0],args: ARGV[1..-1],options: options)
if !command
  log "'#{ARGV[0]}' is not a supported command"
  exit 1
end

exit command.call
