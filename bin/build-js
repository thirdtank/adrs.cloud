#!/usr/bin/env ruby

require_relative "brut_cli"
require "fileutils"
require "json"
require "optparse"

def parse_options
  options = {
    output_file: "app.js",
    source_file: "index.js",
  }
  OptionParser.new do |parser|
    parser.banner = %{Usage: #{$0} [options]

OPTIONS
}
    parser.on("--output-file=FILE","Name of the output file, defaults to #{options[:output_file]}") do |value|
      options[:output_file] = value
    end
    parser.on("--source-file=FILE","Name of the source file, relative to js/, defaults to #{options[:source_file]}") do |value|
      options[:source_file] = value
    end
  end.parse!
  options
end

options = parse_options

js_bundle           = Brut.container.js_bundle_output_dir / options[:output_file]
js_bundle_source    = Brut.container.front_end_src_dir /  "js" / options[:source_file]
metafile            = Brut.container.tmp_dir / "build-js-meta.json"
asset_metadata_file = Brut.container.asset_metadata_file

name_with_hash_regexp = /app\/public\/(?<path>.+)\/(?<name>.+)\-(?<hash>.+)\.js/

command = "npx esbuild --metafile=#{metafile} --entry-names=[name]-[hash] --sourcemap --bundle #{js_bundle_source} --outfile=#{js_bundle}"
env_for_command = {
  "NODE_PATH" => (Brut.container.project_root / "lib").to_s, # Not needed once Brut is properly bundled
}
log "Building JS bundle '#{js_bundle}' with '#{command}'"
system!(env_for_command,command)

if !File.exist?(metafile)
  log "'#{metafile}' was not generated - cannot continue"
  exit 1
end

log "Parsing metafile '#{metafile}'"
metafile_contents = JSON.parse(File.read(metafile))

metadata = metafile_contents["outputs"].keys.map { |key|
  match_data = key.match(name_with_hash_regexp)
  if match_data
    path = match_data[:path]
    name = match_data[:name]
    hash = match_data[:hash]

    [ "/#{path}/#{name}.js", "/#{path}/#{name}-#{hash}.js" ]
  else
    nil
  end
}.compact.to_h

log "Reading asset metadata file '#{asset_metadata_file}'"
asset_metadata = if File.exist?(asset_metadata_file)
                   JSON.parse(File.read(asset_metadata_file))
                 else
                   log "'#{asset_metadata_file}' does not exist - creating it"
                   { "asset_metadata" => {} }
                 end
existing_metadata = asset_metadata["asset_metadata"][".js"]
asset_metadata["asset_metadata"][".js"] = existing_metadata.merge(metadata)

log "Writing updated asset metadata file '#{asset_metadata_file}'"
File.open(asset_metadata_file,"w") do |file|
  file.puts asset_metadata.to_json
end
